// AUTO GENERATED FILE, DO NOT EDIT.
// Generated by `flutter_rust_bridge`@ 1.81.0.
// ignore_for_file: non_constant_identifier_names, unused_element, duplicate_ignore, directives_ordering, curly_braces_in_flow_control_structures, unnecessary_lambdas, slash_for_doc_comments, prefer_const_literals_to_create_immutables, implicit_dynamic_list_literal, duplicate_import, unused_import, unnecessary_import, prefer_single_quotes, prefer_const_constructors, use_super_parameters, always_use_package_imports, annotate_overrides, invalid_use_of_protected_member, constant_identifier_names, invalid_use_of_internal_member, prefer_is_empty, unnecessary_const

import 'dart:convert';
import 'dart:async';
import 'package:meta/meta.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge.dart';
import 'package:uuid/uuid.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;

part 'bridge_definitions.freezed.dart';

abstract class Native {
  Future<void> init({dynamic hint});

  FlutterRustBridgeTaskConstMeta get kInitConstMeta;

  Future<List<Trip>> getTrips({dynamic hint});

  FlutterRustBridgeTaskConstMeta get kGetTripsConstMeta;

  Future<Trip> createTrip({required CreateTrip command, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kCreateTripConstMeta;

  Future<List<PackingListEntry>> getPackingList({dynamic hint});

  FlutterRustBridgeTaskConstMeta get kGetPackingListConstMeta;

  Future<PackingListEntry> addPackingListEntry(
      {required AddPackingListEntry command, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kAddPackingListEntryConstMeta;

  Future<void> deletePackingListEntry(
      {required DeletePackingListEntry command, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kDeletePackingListEntryConstMeta;

  Future<TripPackingListModel> getTripPackingList(
      {required UuidValue tripId, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kGetTripPackingListConstMeta;

  Future<void> markAsPacked(
      {required UuidValue tripId, required UuidValue entryId, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kMarkAsPackedConstMeta;

  Future<void> markAsUnpacked(
      {required UuidValue tripId, required UuidValue entryId, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kMarkAsUnpackedConstMeta;

  Future<List<LocationEntry>> searchLocations(
      {required String query, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kSearchLocationsConstMeta;

  Future<void> addTripLocation(
      {required AddTripLocation command, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kAddTripLocationConstMeta;

  Future<void> runBackgroundJobs({dynamic hint});

  FlutterRustBridgeTaskConstMeta get kRunBackgroundJobsConstMeta;
}

class AddPackingListEntry {
  final String name;
  final List<PackingListEntryCondition> conditions;
  final Quantity quantity;

  const AddPackingListEntry({
    required this.name,
    required this.conditions,
    required this.quantity,
  });
}

class AddTripLocation {
  final UuidValue tripId;
  final LocationEntry location;

  const AddTripLocation({
    required this.tripId,
    required this.location,
  });
}

class Coordinates {
  final double latitude;
  final double longitude;

  const Coordinates({
    required this.latitude,
    required this.longitude,
  });
}

class CreateTrip {
  final String name;
  final DateTime startDate;
  final DateTime endDate;
  final Uint8List? headerImage;

  const CreateTrip({
    required this.name,
    required this.startDate,
    required this.endDate,
    this.headerImage,
  });
}

class DailyWeatherForecast {
  final DateTime day;
  final double minTemperature;
  final double maxTemperature;
  final double morningTemperature;
  final double dayTemperature;
  final double eveningTemperature;
  final double nightTemperature;
  final WeatherCondition condition;

  /// mm
  final double precipitationAmount;
  final double precipitationProbability;
  final double windSpeed;

  const DailyWeatherForecast({
    required this.day,
    required this.minTemperature,
    required this.maxTemperature,
    required this.morningTemperature,
    required this.dayTemperature,
    required this.eveningTemperature,
    required this.nightTemperature,
    required this.condition,
    required this.precipitationAmount,
    required this.precipitationProbability,
    required this.windSpeed,
  });
}

class DeletePackingListEntry {
  final UuidValue id;

  const DeletePackingListEntry({
    required this.id,
  });
}

class HourlyWeatherForecast {
  final DateTime time;
  final double temperature;
  final double windSpeed;

  /// mm/h
  final double precipitationAmount;
  final double precipitationProbability;
  final WeatherCondition condition;

  const HourlyWeatherForecast({
    required this.time,
    required this.temperature,
    required this.windSpeed,
    required this.precipitationAmount,
    required this.precipitationProbability,
    required this.condition,
  });
}

class Location {
  final Coordinates coordinates;
  final String city;
  final String country;
  final WeatherForecast? forecast;
  final List<TripAttachment> attachments;

  const Location({
    required this.coordinates,
    required this.city,
    required this.country,
    this.forecast,
    required this.attachments,
  });
}

class LocationEntry {
  final String name;
  final Coordinates coordinates;
  final String country;

  const LocationEntry({
    required this.name,
    required this.coordinates,
    required this.country,
  });
}

class PackingListEntry {
  final UuidValue id;
  final String name;
  final List<PackingListEntryCondition> conditions;
  final Quantity quantity;

  const PackingListEntry({
    required this.id,
    required this.name,
    required this.conditions,
    required this.quantity,
  });
}

@freezed
sealed class PackingListEntryCondition with _$PackingListEntryCondition {
  const factory PackingListEntryCondition.minTripDuration({
    required int length,
  }) = PackingListEntryCondition_MinTripDuration;
  const factory PackingListEntryCondition.maxTripDuration({
    required int length,
  }) = PackingListEntryCondition_MaxTripDuration;
  const factory PackingListEntryCondition.minTemperature({
    required double temperature,
  }) = PackingListEntryCondition_MinTemperature;
  const factory PackingListEntryCondition.maxTemperature({
    required double temperature,
  }) = PackingListEntryCondition_MaxTemperature;
  const factory PackingListEntryCondition.weather({
    required WeatherCondition condition,
    required double minProbability,
  }) = PackingListEntryCondition_Weather;
}

class Quantity {
  final int? perDay;
  final int? perNight;
  final int? fixed;

  const Quantity({
    this.perDay,
    this.perNight,
    this.fixed,
  });
}

class Trip {
  final UuidValue id;
  final String name;
  final DateTime startDate;
  final DateTime endDate;
  final List<Location> locations;
  final Uint8List? headerImage;
  final List<TripAttachment> attachments;

  const Trip({
    required this.id,
    required this.name,
    required this.startDate,
    required this.endDate,
    required this.locations,
    this.headerImage,
    required this.attachments,
  });
}

class TripAttachment {
  final UuidValue id;
  final String name;

  const TripAttachment({
    required this.id,
    required this.name,
  });
}

class TripPackingListEntry {
  final PackingListEntry packingListEntry;
  final bool isPacked;
  final bool explicitHidden;
  final bool explicitShown;
  final int? quantity;

  const TripPackingListEntry({
    required this.packingListEntry,
    required this.isPacked,
    required this.explicitHidden,
    required this.explicitShown,
    this.quantity,
  });
}

class TripPackingListModel {
  final List<TripPackingListEntry> visible;
  final List<TripPackingListEntry> hidden;

  const TripPackingListModel({
    required this.visible,
    required this.hidden,
  });
}

enum WeatherCondition {
  Thunderstorm,
  Sunny,
  Rain,
  Clouds,
  Snow,
}

class WeatherForecast {
  final Coordinates coordinates;
  final List<HourlyWeatherForecast> hourlyForecast;
  final List<DailyWeatherForecast> dailyForecast;

  const WeatherForecast({
    required this.coordinates,
    required this.hourlyForecast,
    required this.dailyForecast,
  });
}
